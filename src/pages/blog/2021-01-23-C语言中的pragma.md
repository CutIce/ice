---
templateKey: blog-post
title: pragma
date: 2021-01-23T15:04:10.000Z
featuredpost: false
featuredimage: /img/flavor_wheel.jpg
description: pragma
tags:
  - Study
  - C语言
---

自动步兵车上需要加装多个传感器用于自主避障，最初用过光学传感器，但是实际测量下来效果不佳，识别范围有限，之后曾经打算用激光雷达，从某辆旧车上扒拉下来一个1万8的激光雷达，但是由于数据读取和处理需要的时间成本高昂也不了了之。最后我们打算使用激光测距传感器。在研究[官方文档](https://github.com/nooploop-dev/nlink_unpack)的时候，我发现一些常见但是没有仔细琢磨的地方，查询、学习之后在此做个记录，以免自己忘记。

## #pragma用法

### #pragma pack ： 指定内存对齐

#### 1.对齐是什么？为什么要对齐？

在大一学C++的时候就记得老师提过一句结构体的对齐，当时囿于水平没有实例探究，不了了之。今天看到新买的传感器的示例文档中有这样的代码，不免好奇搜索。

```C
#pragma pack(1)
typedef struct {
	uint8_t id;
    uint8_t role;
    nint24_t pos_3d[3];
    uint16_t dis_arr[8];
} nlt_anchorframe0_tag_raw_t;
#pragma pack()
```

首先了解什么是对齐。

计算机中内存空间依据`Byte`[字节]来划分，在了解前以为对**任何类型的变量**的访问都可以从**任何地址**开始，但实际不是，众多种类的变量是按照一定的规则在内存中排列的，并不是直接有序排列，这就是对齐。

举例来说，比如内存中有一个`char`[1字节]为`0x73`，一个`float`[4字节]为`0x6B 0xEF 0xCC 0x40 `。

内存中：方案一：`0x73 0x6B 0xEF 0xCC 0x40`，也可能是方案二：`0x00 0x00 0x00 0x73 0x6B 0xEF 0xCC 0x40`。也就是虽然前面只有1个`char`，但是实际上用了4个`Byte`来存储这个`char`，它的作用就是和后面的`float`对齐，方便系统读取数据。

接上例，如果是方案一，系统如果想要读到`char`型的`0x73`就需要一个字节一个字节的读取，那么在读取`float`时就需要读取四次才能拼接成功。也就是说每次读1`Byte`时，读这两个数据需要读5次，花费时间为`5t`。

如果是方案二，每次系统读取4个字节，那么系统读取这两个数据只需要读两次，可以大大节省系统时间，但是需要消耗系统内存的空间。即以空间换时间。这也是为什么对齐的原因。

#### 2.#pragma pack的语法

4字节对齐方式确实可以提高CPU存储变量的速度，但也会带来麻烦。所以我们也可以自己设定变量的对齐方式。

`#pragma pack(n)`可以设置结构体的对齐方式，其中n为指定的“对齐系数”（对齐模数）。从结构体的第一个变量开始，不足n字节的变量要补足，使得每次读n个字节均能读到整数个变量。

例如：

```C
#pragma pack(4) 
struct node {
	char  a;
    int   b;
    short c;
    char  d;
}
#pragma pack
```

如果输出`sizeof(node)`可以发现值为12，a这是因为char是一个字节，后面的int是四个字节，开头的4个字节只能包含第一个a，如果硬要包含b，b将拆成两部分，更难处理，所以要给 a补齐3个字节的0让a占满4字节。对于b，它自动占据了4个字节。对于c和d而言，`short int`占据了2个字节，和1个char一共占据3个字节。所以四个字节可以一次将它们读出来。

也就是说，每个变量按自己长度和pack参数中的较小值来进行对齐。

| 语句                   | 作用                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `#pragma pack(n)`      | 编译器按n个字节方式对齐                                      |
| `#pragma pack()`       | 取消自定义字节对齐模式                                       |
| `#pragma pack(push 1)` | 把原来的对齐方式设置压栈<br>设置新的对齐方式设置为1个字节对齐 |
| `#pragma pack(pop)`    | 恢复之前的对齐状态<br>恢复原来状态而不是编译器默认状态       |

在内存对齐中还有几个概念如偏移地址等，较为简单就不再赘述。

### message 参数

`#pragma message("文本消息")`编译器遇到指令时就在编译输出窗口将消息打印出来。

### \#pragma once

在头文件中加入这个指令就能保证头文件只被编译一次。

同时这个指令还是编译相关的，和编译器有关系。在一个编译器上能跑，在另一个编译器上不一定能跑。



## 参考目录

1. [\#Pragma Pack(n)与内存分配 pragma pack(push,1)与#pragma pack(1)的区别](https://blog.csdn.net/aidem_brown/article/details/77540527)

